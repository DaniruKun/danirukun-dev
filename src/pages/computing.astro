---
import { SITE_TITLE, SITE_DESCRIPTION } from '../consts';
import BaseHead from '../components/BaseHead.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
---

<!doctype html>
<html lang="en">
	<head>
		<BaseHead title={SITE_TITLE} description={SITE_DESCRIPTION} />
	</head>
	<body>
		<Header title={SITE_TITLE} />
		<main>

			<h1 id="laptop" class="text-4xl">Laptop</h1>
			<p>
				At the moment, I use a touchbar 13” Macbook Pro (Intel), which for now is enough for my
				needs (quad-core CPU, 16GB of memory). Even though this model does not have a great keyboard
				(which already failed once and had to be replaced, thankfully for free, by Apple), it has a
				fantastic screen, amazing track pad, and is quite light and small.
			</p>
			<p>
				MacOS is
				<a
					href="https://blog.opengroup.org/2012/07/25/apple-registers-mac-os-x-10-8-mountain-lion-to-the-unix-03-standard/"
					>POSIX-compliant</a
				>, so some GNU utils you might be used to are either missing or are severely outdated out of
				the box, but this doesn’t really hinder my work, and overall the macOS experience is a very
				pleasant and stable one, providing good enough defaults and flexibility, and great
				integration with the Apple ecosystem.
			</p>
			<h1 id="keyboard" class="text-4xl">Keyboard</h1>
			<p>
				When I am at a desk, I only use my
				<a href="https://www.hhkeyboard.com/uk/products/hybrid"
					>Happy Hacking Keyboard Professional Hybrid</a
				>. It is a very minimal keyboard with no separate arrow keys or a numpad (which, as a
				programmer, I never have a need for), which makes it very symmetrical and reduces my hand
				movement. It has a Sun Type 3 arrangement, so the <code>Ctrl</code> key is already to the
				left of <code>A</code>, which is perfect for me as an Emacs and terminal user. The keys are
				slightly curved, are made of high quality PBT plastic, and have unique Topre switches, which
				are very pleasant to type on. I got the Hybrid model, because it offers Bluetooth
				connectivity with fast switching between 4 devices, and uses standard AA batteries.
			</p>
			<h1 id="head-mounted-display-hmd" class="text-4xl">Head Mounted Display (HMD)</h1>
			<p>
				I currently own a <a href="https://www.meta.com/quest/quest-pro/">Meta Quest Pro</a>, which
				at the time of writing is the latest HMD from Meta. While being very expensive (at 1800 EUR
				MSRP in Europe!), it is a very cool piece of tech, and really amazing for being my first
				headsets that I genuinely wanted to use every day. What I like about it the most:
			</p>
			<ul>
				<li>Very clear and light pancake optics</li>
				<li>Extremely simple mechanism for taking off and putting back on</li>
				<li>Open design with optional light blocker, no face pressure</li>
				<li>
					Fantastic, fully self-tracked controllers that feel amazing (except for the hand straps)
				</li>
				<li>Generally quite polished software and regular updates</li>
				<li>
					Works amazingly well with PCVR wirelessly over Virtual Desktop app, as well as for work
				</li>
				<li>Special charging dock with pogo pins</li>
			</ul>
			<h1 id="editor-ide-whatever" class="text-4xl">Editor / IDE / whatever</h1>
			<p>
				I use <a href="https://github.com/d12frosted/homebrew-emacs-plus">emacs-plus</a> of version
				<code>28</code> with native compilation, since it is now stable enough, and is noticeably
				faster than the <code>27</code> branch.
			</p>
			<p>
				For me, Emacs is the only editor that has managed to make it possible to develop for every
				language that I have some familiarity with: Python, Ruby, Java, JavaScript, Clojure, Erlang,
				Elixir and Lisp. The flexibility and extensibility it offers, combined with the amazing
				<a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a>
				and the <a href="https://emacs-lsp.github.io/lsp-mode/">Emacs-LSP</a> client, makes Emacs a
				very compelling environment.
			</p>
			<p>
				Of course, Emacs can do so much more than just edit code - read news, browse RFCs, fetch
				data from web APIs, manage Kubernetes clusters, organize notes and tasks. Having as many of
				these actions in one system greatly reduces context switching, and reduces the overhead of
				having to manage different applications, where each has a different set of UIs, menus, key
				bindings and conventions.
			</p>
			<p>
				I still dabble in Visual Studio Code once in a while, simply because some extensions work
				better there, and the Github extensions are quite nice, allowing you to almost never leave
				the editor when doing typical development in a team.
			</p>
			<h1 id="other-tools" class="text-4xl">Other tools</h1>
			<p>
				The tools mentioned here are those that I either have not learned to use in Emacs, or don’t
				exist yet, don’t have the features I need, or are just more user-friendly.
			</p>
			<h2 id="mail-calendar-photos-maps" class="text-2xl">Mail / Calendar / Photos / Maps</h2>
			<p>
				I try to avoid unnecessary duplication and redundancy, and prefer to use what is already
				given to me, so I tend to stick with the applications Apple provides on their operating
				systems. Apple Mail and the like has been working fine for me for a few years, and am not
				compelled to switch to anything else at the moment.
			</p>
			<h2 id="development" class="text-2xl">Development</h2>
			<p>
				Here are a number of tools I have collected over the years in no particular order that I
				have found of great value:
			</p>
			<ul>
				<li>
					<a href="https://iterm2.com">iTerm2</a>, still in my opinion the best terminal emulator
					available for macOS
				</li>
				<li>
					<a href="https://insomnia.rest">Insomnia</a>, a very nice REST client that supports HTTP
					and gRPC, as well as has advanced features like code generation
				</li>
				<li>
					<a href="https://minikube.sigs.k8s.io/docs/">Minikube</a>, a lightweight k8s
					implementation that is great for running development services locally and get rid of
					Docker Desktop
				</li>
				<li>
					<a href="https://dash.plotly.com">Dash</a>, a fantastic documentation viewer for all of
					your language and library needs, that integrates with editors too
				</li>
				<li>
					<a href="https://openai.com/blog/chatgpt/">ChatGPT</a>: if you aren’t using it already,
					you are literally wasting your time. It is like having a super smart human next to you
					that you can ask questions, and ask to do menial tasks in seconds.
				</li>
			</ul>
			<h2 id="programming-languages" class="text-2xl">Programming Languages</h2>
			<h3 id="scripting-interpreted">Scripting / interpreted</h3>
			<p>
				Python and Ruby are good for what they were made for - scripting, as well as web frameworks
				and web frameworks. However, I would not say I am a big fan of them, due to their lack of
				decent type checking, flexibility and performance.
			</p>
			<h3 id="compiled">Compiled</h3>
			<p>
				Clojure is a great language to use if you need to use the JVM. It is the most functional and
				elegant language that I know of that compiles to Java byte code, and is a great way to get
				introduced to lisps. The reason for this is the great tooling and very friendly and creative
				community. Of course, Rich Hickey himself is a feature of the language.
			</p>
			<p>
				If you have never touched the BEAM, you have never known how elegant and powerful a virtual
				machine can be. Erlang and Elixir are functional, strictly typed languages that run on the
				BEAM VM, and make problems such as scalability, distribution, caching and multiprocessing
				actually solvable, using a very small set of tools. I think every programmer that has
				anything to do with the web must at least try out Elixir or Erlang.
			</p>
			<p>
				Golang, or more commonly Go, is a really neat and simple language created inside of Google
				with the goal to be a replacement for C, Java and Python. It’s main appeal is a very shallow
				learning curve, solid standard library, and of course fast execution speed and minimal
				memory footprint. I found myself becoming very productive with it within days if not hours,
				and it has solid support for concurrency, which in my eyes is an important requirement in
				the modern multicore world. It is not as high level as some other languages, but it makes up
				for it in terms of performance.
			</p>
			<p>
				Common Lisp is a very alien language, and rightfully so. The amount of flexibility and
				choice it gives to the programmer is mind blowing, and can be quite overwhelming. It is not
				just a tool - it is the bricks and the circuits to allow you to make your own hammers and
				drills. You want to write in a functional style? You can. You want static typing, ADTs,
				threading macros and also call C code? It’s all available, usually just a package away. You
				can get very far with just the core library and a few libraries, but most often than not
				people create their own DSL for their problem domain.
			</p>
		</main>
		<Footer />
	</body>
</html>
